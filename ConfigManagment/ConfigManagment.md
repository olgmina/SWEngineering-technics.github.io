# Конфигурационное управление

**Software Configuration Management (SCM)**:  Конфигурационное управление  — комплекс методов, направленных на систематический учёт изменений, 
вносимых разработчиками в программный продукт в процессе его разработки и сопровождения, сохранение целостности системы после изменений, 
предотвращение нежелательных и непредсказуемых эффектов, формализацию процесса внесения изменений.

Включает следующие принципы:

Дисциплины | Виды работ
------------ | -------------
Конфигурационная идентификация | Документы создаются для описания продукта и являются средством управления конфигурацией продукта
Контроль конфигурации  | Изменения в продукте контролируются посредством контроля изменений в документации.
Контроль конфигурации  | Изменения в продукте не производятся до тех пор, пока они не сделаны в документации.
Контроль конфигурации  | До того, как быть реализованными в документации и продукте, изменения должны быть формально утверждены.
Контроль конфигурации  | Все изменения должны отслеживаться.
Контроль конфигурации  | Конфигурационные объекты (продукты), документы и их версии нумеруются и именуются единообразно и недвусмысленно (или уникально)
Учет состояния конфигурации | Ведется отчетность о состоянии изменений, документов и продуктов
Ревизия и аудит конфигурации | Каждый документ периодически сравнивается с соответствующим ему документом верхнего уровня на предмет выявления несоответствий.
Ревизия и аудит конфигурации | Продукт в целом сравнивается со своим описанием (конфигурационной идентификацией) и должен этому описанию соответствовать.


Семантическое версионирование (SemVer) — это соглашение об именовании, применяемое к версиям библиотеки для обозначения ключевых вех. В идеале сведения о версии, включаемые в библиотеку, должны помочь разработчикам определить совместимость с проектами, в которых используются предыдущие версии этой библиотеки.

Базовым вариантом SemVer является трехкомпонентный формат MAJOR.MINOR.PATCH, где:

1. MAJOR увеличивается при внесении изменений, приводящих к несовместимости API;
2. MINOR увеличивается при добавлении функциональных возможностей с обеспечением обратной совместимости;
3. PATCH увеличивается при исправлении ошибок с обеспечением обратной совместимости.

## Git
Git — распределённая система контроля версий, созданная Линус Торвальдс,


1. [x] Изучите [руководство по git](https://github.com/olgmina/SWEngineering-technics.github.io/blob/8f8e3861b2c7ccc1be2c5c24ad444448a5b3b664/ConfigManagment/progit_v2.1.18.pdf)
2. [x] [Выполните практику](https://learngitbranching.js.org/)

_Задание 1_ Индивидуальная работа с git

1. Создайте репозиторий (проект c Игрой) в своем [Github](https://docs.github.com/en/github/getting-started-with-github/set-up-git).

__ИЛИ__ Создайте [проект](https://guides.github.com/activities/hello-world)

2. Копируйте (или клонируйте) репозиторий на локальный компьютер (В Idea <open SCM>).
 
_Вместо 1_ Из каталога выберите [проект](https://github.com/olgmina/student-project-catalog.git) и загрузите его в среду разработки,
 
4. Добавьте файл (source) в локальный репозиторий и выполните коммит (сохраните изменения).
 
5. Отправьте (push) изменения в главную ветку.
 
6. Измените файл readme.md с помощью [инструментов хостинга Github](https://guides.github.com/features/wikis/) и выполните коммит.
 
7. Скопируйте (pull) изменения на локальный компьютер.
 
8. Создайте [ветку](https://guides.github.com/activities/forking/) (версию), внесите изменения, сделайте коммит изменений.
 
9. Создайте запрос pull (предложите включить изменения в главную ветку).
 
10. Выполните слияние (merge) вашей ветки с главной веткой.

### Отчет

 подписка на Ваш репозиторий (пришлите мне приглашение на участие в Вашем проекте)

 _Задание 2_ 

 _Задание 3_ Проектная работа с git
 
Последовательность действий при работе по модели Gitflow:

1. Из ветки __main__ создаётся ветка __develop__.

2. Из ветки __develop__ создаётся ветка __release___.Когда работа над веткой релиза release завершена, она сливается в ветки __develop__ и __main__.
 
3. Из ветки __develop__ создаются ветки __feature__. Когда работа над веткой feature завершена, она сливается с веткой __develop__.

4. Если в __main__ обнаружена проблема, из master создаётся ветка __hotfix__.
Когда работа над веткой исправления __hotfix__ завершена, она сливается в ветки __develop__ и __main__.
 
