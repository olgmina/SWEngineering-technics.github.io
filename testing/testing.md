# Тестирование программного обеспечения (Software Testing)
**проверка соответствия между реальным и ожидаемым поведением программы, 
осуществляемая на конечном наборе тестов, выбранном определенным образом** [IEEE Guide to Software Engineering Body of Knowledge, SWEBOK, 2004](https://github.com/ligurio/swebok-v3/blob/master/4_software_testing.markdown) 
В более широком смысле, тестирование - это одна из техник контроля качества, включающая:
1. планирование работ (Test Management), 
2. проектирование тестов (Test Design), 
3. выполнение тестирования (Test Execution)
4. анализ полученных результатов (Test Analysis).

## Виды тестирования: функциональное
**Функциональные тесты** основываются на функциях, выполняемых системой и 
описаны в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases),
могут проводиться на всех уровнях тестирования (модульном, интеграционном, системном, приемочном).

Используют методы "черного ящика" [указания по технике использования](https://github.com/olgmina/SWEngineering-technics.github.io/blob/871f799b2b8e2742cfd92227df6bea77fd0da025/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%20%D1%82%D0%B5%D1%81%D1%82%20%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0%20%D0%BF%D1%80%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%20%D0%BA%D0%B5%D0%B9%D1%81%D0%BE%D0%B2%20.pdf):
    - Эквивалентное Разделение (Equivalence Partitioning)
    - Анализ Граничных Значений (Boundary Value Analysis)
    - Предупреждение ошибок (Error Guessing)
    - Анализ причинно-следственных связей (таблиц илил деревьев решений) (Cause/Effect)
    
### Задания по функциональному тестированию

1. Составить набор тестов для проверки формы ввода данных [программы  Менеджер паролей]

| Элемент | Тип элемента | Требования |
| --- | --- | --- |
| Выбор действия | вкладка | Разделы: Генерация пароля/Управление паролями |
| Логин | текстовое поле | обязательно для заполнения, только латинские буквы, не более 10 и не менее 3 |
| Пароль | текстовое поле | обязательно для заполнения, не менее 8 (максимум 32), допустимы цифры, символы [!@#$%^&+] |
| Запуск | кнопка | Пока не заполнены логин и пароль - не активна, после нажатия – сообщение об успешном создании нового пароля, если выбрано «Управление».Если выбрано «Генерация пароля» кнопка сразу активна и после заполнения поля логин в поле «Пароль» формируется новая цифровая комбинация |

__Методические указания по выполнению задания.__
1. Для выбора тестовых данных для каждого поля определите классы эквивалентности.
*Например, для поля Логин класс допустимых значений  - буква, недопустимых - цифра, специальный символ
Категория "поле обязательно для заполнения" также подразумевает два класса - введено корректное значение или - ничего не введено или - введена недопустимая комбинация*
2. Для каждого класса допустимых значений поля определите граничные значения
*например, допустимо от 3 до 10 символов, следовательно граничные значения 2, 3, 10, 11 символов используется для теста*
3. Полученные значения входных данных сгруппируйте в диаграмму причинно-следственных связей  (булевский граф или таблица), связывающий причины и следствия. 
*Каждая вершина графа может находиться в состоянии «успешная генерация»/"успешное изменение пароля" или «ошибка генерации»/"невозможно изменить пароль", от них следуют комбинации полей и их значений*
4. Минимально достаточные комбинации занесите в [тест-кейс](https://github.com/olgmina/SWEngineering-technics.github.io/blob/a4182083f69d092e9824bf5863753168777416aa/TestCase_example.doc)

## Виды тестирования: Структурное
**Модульные тесты**  или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.
Идея состоит в том, чтобы написать тесты для каждой сложной функции или метода и выполнять их отдельно (модульно).  Специальный драйвер позволяет запустить на выполнение только задействованный в тесте фрагмент кода тестируемой программы и используя методы специальной библиотеки **JUnit** сравнить ожидаемые результаты с полученными  Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок. 
Unit (Элемент) — наименьший компонент, который можно скомпилировать. Unit-тесты - это отдельные классы,  написанные на языке программирования с использованием следующих языковых средств библиотеки JUnit [подробно](https://github.com/olgmina/SWEngineering-technics.github.io/blob/7214cd1cc335fe75f2d043da6e9e447fe9b26e27/testing/junit.md)

### Таблица 1. Аннотации.

| Аннотация | Описание |
|--- | --- |
|@Test public void method()| Помечает метод как тестовый|
|@Before public void method() | Метод будет выполняться перед каждым тестом, может быть использован для подготовки тестового окружения (инициализации, чтения данных)|
| @After public void method() | Метод будет выполняться после каждого теста. Может использоваться для отчистки окружения, удаления временных данных.|
| @Ignore | Метод будет проигнорирован. Это может быть использовано, если код был изменен, а тесты еще не были адаптированы или если время выполнения теста очень велико |
| @Test(expected=IllegalArgumentException.class) | Проверка на ожидаемое исключение. Тест будет считаться не пройденным, если будет сгенерировано другое исключение |
| @Test(timeout=100) | Проверка на таймаут. Тест будет считаться не пройденным, если время выполнения окажется больше указанного |

## Таблица 2. Тестовые методы

| Сигнатура | Описание |
|--- | --- |
| fail(String) | Вызывает сбой. Может быть использован, чтобы удостовериться, что определенная часть кода не достигнута или пока тестовый метод не реализован |
| assertTrue(true) / assertTrue(false) | Постоянно будет true / false. Может быть использован, чтобы предопределить результат теста, пока он не реализован |
| assertsEquals([String message], expected, actual) | Проверяет, равны ли две величины. Важно: для массивов проверяется ссылка а не содержимое|
| assertsEquals([String message], expected, actual, **tolerance**) | Проверяет, совпадают ли величины  float и double  с заданной точностью tolerance |
| assertNull([message], object) | Проверяет, что объект null |
| assertSame([String], expected, actual) | Проверяет, что обе переменные ссылаются на один объект |
| assertTrue([message], boolean condition) | Проверяет условие на истинность |

 *Пример:*
```
public class MathTest {
    @Test
    public void testEquals() {
        Assert.assertEquals(4, 2 + 2);
        Assert.assertTrue(4 == 2 + 2);
    }
    @Test
    public void testNotEquals() {
        Assert.assertFalse(5 == 2 + 2);
   }
}
```
Драйверы — модули тестов, которые запускают тестируемый элемент.

Заглушки — заменяют недостающие компоненты, которые вызываются элементом и выполняют следующие действия: 

● возвращаются к элементу, не выполняя никаких других действий;
● отображают трассировочное сообщение и иногда предлагают тестеру продолжить тестирование;
● возвращают постоянное значение или предлагают тестеру самому ввести возвращаемое значение;
● осуществляют упрощенную реализацию недостающей компоненты;
● имитируют исключительные или аварийные условия.       

Про другие инструменты автоматизированного тестирования  [см.](https://tproger.ru/translations/12-tools-for-unit-tests/)

[Инструкция по созданию тестов в среде разработке](https://github.com/olgmina/SWEngineering-technics.github.io/blob/7ac20eac45017ce3e663d58bf1919e3067e75042/testing/Instruction.md)

### Задание по unit-тестированию

Напишите unit-тест для одного из классов Вашего приложения
**Методические рекомендации.
1. __Для тестирования любого метода класса необходимо:___ 
* Определить, какая часть функциональности метода должна быть протестирована, то есть при каких условиях он должен вызываться. Под условиями здесь понимаются параметры вызова методов, значения полей и свойств объектов, наличие и содержимое используемых файлов и т. д. 
* Создать тестовое окружение, обеспечивающее требуемые условия. 
* Запустить тестовое окружение на выполнение. 
* Обеспечить сохранение результатов в файл для их последующей проверки. 
* После завершения выполнения сравнить полученные результаты со спецификацией. 

2. __Для работы с unit-тестами надо добавить в проект необходимые библиотеки__
- 2.1 Библиотеки для JUnit и TestNG поставляются с IntelliJ IDEA, но по умолчанию не включены в путь к классам вашего проекта или модуля. Следовательно, при создании тестового класса ссылки на класс TestCase или текстовые аннотации не разрешаются. Чтобы добавить необходимую библиотеку в путь к классам, вы можете использовать общую процедуру добавления зависимости к модулю. Соответствующие библиотеки расположены в следующих каталогах:
* JUnit библиотеки ( junit.jar и junit-4.12.jar): <IntelliJ IDEA directory>\lib;
* библиотека TestNG (testng-jdk15.jar): <IntelliJ IDEA directory>\plugins\testng\lib.
* ~~hastem - <IntelliJ IDEA directory>\plugins\testng\lib.~~

    IntelliJ IDEA может автоматически добавить необходимую библиотеку в путь к классам (Настройки проекта - Библиотеки) . 

- 2.2 Необходимо также  добавить в проект путь к классам тестов (они должны выделится зеленым).
```
src / main / java - для классов Java
src / test / java - для тестовых классов
```
- 2.3 Для создания теста в **редакторе кода** поместите курсор в строку, содержащую объявление класса. Нажмите Alt+Enter, чтобы просмотреть доступные намеренные действия. Выберите «Создать тест». (Обратите внимание **JUnit 4.12*** требуется)

3. Посмотрите [пример 1](https://github.com/olgmina/SWEngineering-technics.github.io/blob/28eac7ea8a68f47af6794c159906f66a7daa2bed/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%201%20%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%9A%D0%B0%D0%BB%D1%8C%D0%BA%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0.pdf), и протестируйте аналогичным образом работу Процентного калькулятора Task0 или любой текущей Task


**Отчет по должен содержать**
1. Код тестируемого класса из одного из Ваших проектов (programm)
2. Тест для проверки метода тестируемого класса
3. Тест для проверки интерфейса тестируемого класса
4. Тест проверки ошибочных условий либо покрытия двух путей.
- *ИЛИ на github  к  существующему Вашему проекту  добавить папку Test, в которой эти тесты разместить и прислать мне ссылку*

