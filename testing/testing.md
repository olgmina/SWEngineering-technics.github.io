# Тестирование программного обеспечения (Software Testing)
**проверка соответствия между реальным и ожидаемым поведением программы, 
осуществляемая на конечном наборе тестов, выбранном определенным образом** [IEEE Guide to Software Engineering Body of Knowledge, SWEBOK, 2004](https://github.com/ligurio/swebok-v3/blob/master/4_software_testing.markdown) 
В более широком смысле, тестирование - это одна из техник контроля качества, включающая:
1. планирование работ (Test Management), 
2. проектирование тестов (Test Design), 
3. выполнение тестирования (Test Execution)
4. анализ полученных результатов (Test Analysis).

## Виды тестирования: функциональное
**Функциональные тесты** основываются на функциях, выполняемых системой и 
описаны в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases),
могут проводиться на всех уровнях тестирования (модульном, интеграционном, системном, приемочном).

Используют методы "черного ящика" [указания по технике использования](https://github.com/olgmina/SWEngineering-technics.github.io/blob/871f799b2b8e2742cfd92227df6bea77fd0da025/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%20%D1%82%D0%B5%D1%81%D1%82%20%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0%20%D0%BF%D1%80%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%20%D0%BA%D0%B5%D0%B9%D1%81%D0%BE%D0%B2%20.pdf):
    - Эквивалентное Разделение (Equivalence Partitioning)
    - Анализ Граничных Значений (Boundary Value Analysis)
    - Предупреждение ошибок (Error Guessing)
    - Анализ причинно-следственных связей (таблиц илил деревьев решений) (Cause/Effect)
    
## Задания по функциональному тестированию

Задание 1. Составить набор тестов для проверки формы ввода данных [программы  Менеджер паролей]

| Элемент | Тип элемента | Требования |
| --- | --- | --- |
| Выбор действия | вкладка | Разделы: Генерация пароля/Управление паролями |
| Логин | текстовое поле | обязательно для заполнения, только латинские буквы, не более 10 и не менее 3 |
| Пароль | текстовое поле | обязательно для заполнения, не менее 8 (максимум 32), допустимы цифры, символы [!@#$%^&+] |
| Запуск | кнопка | Пока не заполнены логин и пароль - не активна, после нажатия – сообщение об успешном создании нового пароля, если выбрано «Управление».Если выбрано «Генерация пароля» кнопка сразу активна и после заполнения поля логин в поле «Пароль» формируется новая цифровая комбинация |

__Методические указания по выполнению задания.__

1. Для выбора тестовых данных для каждого поля определите классы эквивалентности.
*Например, для поля Логин класс допустимых значений  - буква, недопустимых - цифра, специальный символ
Категория "поле обязательно для заполнения" также подразумевает два класса - введено корректное значение или - ничего не введено или - введена недопустимая комбинация*
2. Для каждого класса допустимых значений поля определите граничные значения
*например, допустимо от 3 до 10 символов, следовательно граничные значения 2, 3, 10, 11 символов используется для теста*
3. Полученные значения входных данных сгруппируйте в диаграмму причинно-следственных связей  (булевский граф или таблица), связывающий причины и следствия. 
*Каждая вершина графа может находиться в состоянии «успешная генерация»/"успешное изменение пароля" или «ошибка генерации»/"невозможно изменить пароль", от них следуют комбинации полей и их значений*
4. Минимально достаточные комбинации занесите в [тест-кейс](https://github.com/olgmina/SWEngineering-technics.github.io/blob/a4182083f69d092e9824bf5863753168777416aa/TestCase_example.doc)

Задание 2. Разработать тестовые сценарии для компьютерной игры [программы  Click-игры]

1. Определите сценарий использования (сначала - позитивный, потом - негативный, 
2. Определите последовательность действий для достижения результата по выбранному сценарию для исследуемой программы
3. Заполните [тест-кейс](https://github.com/olgmina/SWEngineering-technics.github.io/blob/a4182083f69d092e9824bf5863753168777416aa/TestCase_example.doc)
4. Выберите другой сценарий и повторите с шага 1.

### Правила написания тест-кейсов

 _Порядковый номер тест кейса_
_Название тест кейса__ Из него должно быть понятно, в чем суть тест кейса
_Предусловия тест кейса_ Это условия, которые необходимы для проведения тест кейса. Они должны быть выполнены еще до запуска тест кейса.

У тест кейса может быть 3 вида результатов:
1. Положительный результат тест кейса. Фактический результат тест кейса совпадает с ожидаемым.
2. Отрицательный результат тест кейса. Фактический результат тест кейса отличается от ожидаемого.
3. Тест кейс не завершен. В процессе проверки тест кейса происходит ошибка.

Существуют 6 правил проведения тест кейсов:
1. Один тест кейс должен проверять только одну конкретную вещь.
2. Тест кейс не должен зависеть от других тест кейсов.
3. Шаги и ожидаемый результат тест кейса должны быть сформулированы четко и однозначно.
4. В тест кейсе должна быть вся информация. необходимая для его проведения.
5. В тест кейсе не должно быть лишних деталей.
6. Для каждого шага тест кейса нужно указывать тип вводимых данных: валидный или невалидный.

[Примеры написания сценариев](https://github.com/olgmina/SWEngineering-technics.github.io/blob/c4323c56b643e060fcfb48e5268e1b452ead21e1/testing/%D0%A2%D0%B5%D1%81%D1%82-%D0%BA%D0%B5%D0%B9%D1%81%D1%8B%20Click-%D0%B8%D0%B3%D1%80%D1%8B.xlsx)

## Виды тестирования: Структурное
**Модульные тесты**  или юнит-тестирование (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.
Идея состоит в том, чтобы написать тесты для каждой сложной функции или метода и выполнять их отдельно (модульно).  Специальный драйвер позволяет запустить на выполнение только задействованный в тесте фрагмент кода тестируемой программы и используя методы специальной библиотеки **JUnit** сравнить ожидаемые результаты с полученными  Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок. 

Unit (Элемент) — наименьший компонент, который можно скомпилировать. Unit-тесты - это отдельные классы,  написанные на языке программирования с использованием следующих языковых средств библиотеки JUnit [подробно](https://github.com/olgmina/SWEngineering-technics.github.io/blob/7214cd1cc335fe75f2d043da6e9e447fe9b26e27/testing/junit.md)

__Таблица 1. Аннотации__

| Аннотация | Описание |
|--- | --- |
|@Test public void method()| Помечает метод как тестовый|
|@Before public void method() | Метод будет выполняться перед каждым тестом, может быть использован для подготовки тестового окружения (инициализации, чтения данных)|
| @After public void method() | Метод будет выполняться после каждого теста. Может использоваться для отчистки окружения, удаления временных данных.|
| @Ignore | Метод будет проигнорирован. Это может быть использовано, если код был изменен, а тесты еще не были адаптированы или если время выполнения теста очень велико |
| @Test(expected=IllegalArgumentException.class) | Проверка на ожидаемое исключение. Тест будет считаться не пройденным, если будет сгенерировано другое исключение |
| @Test(timeout=100) | Проверка на таймаут. Тест будет считаться не пройденным, если время выполнения окажется больше указанного |

__Таблица 2. Тестовые методы__

| Сигнатура | Описание |
|--- | --- |
| fail(String) | Вызывает сбой. Может быть использован, чтобы удостовериться, что определенная часть кода не достигнута или пока тестовый метод не реализован |
| assertTrue(true) / assertTrue(false) | Постоянно будет true / false. Может быть использован, чтобы предопределить результат теста, пока он не реализован |
| assertsEquals([String message], expected, actual) | Проверяет, равны ли две величины. Важно: для массивов проверяется ссылка а не содержимое|
| assertsEquals([String message], expected, actual, **tolerance**) | Проверяет, совпадают ли величины  float и double  с заданной точностью tolerance |
| assertNull([message], object) | Проверяет, что объект null |
| assertSame([String], expected, actual) | Проверяет, что обе переменные ссылаются на один объект |
| assertTrue([message], boolean condition) | Проверяет условие на истинность |

[__Документация по junit5__](https://junit.org/junit5/docs/current/user-guide/)
 
 *Пример:*
```
import junit.framework.*;

public class JavaTest extends TestCase {
   protected int value1, value2;
   
   // создание условия запуска
   protected void setUp(){
      value1 = 3;
      value2 = 3;
   }

   // тестовый метод для сложения двух значений
   public void testAdd(){
      double result = value1 + value2;//выполнение
      assertTrue(result == 6);//проверка
   }
}
```
Драйверы — модули тестов, которые запускают тестируемый элемент.

Заглушки — заменяют недостающие компоненты, которые вызываются элементом и выполняют следующие действия: 

- возвращаются к элементу, не выполняя никаких других действий;
- отображают трассировочное сообщение и иногда предлагают тестеру продолжить тестирование;
- возвращают постоянное значение или предлагают тестеру самому ввести возвращаемое значение;
- осуществляют упрощенную реализацию недостающей компоненты;
- имитируют исключительные или аварийные условия.       

[Инструкция по созданию тестов в среде разработке](https://github.com/olgmina/SWEngineering-technics.github.io/blob/7ac20eac45017ce3e663d58bf1919e3067e75042/testing/Instruction.md)


## Задание 4. Напишите unit-тест для одного из классов модели Вашего приложения [программа Процентный калькулятор]

__Методические рекомендации по выполнению задания__

1. __Для тестирования любого метода класса необходимо:__
* Определить, какая часть функциональности метода должна быть протестирована, то есть при каких условиях он должен вызываться. Под условиями здесь понимаются параметры вызова методов, значения полей и свойств объектов, наличие и содержимое используемых файлов и т. д. 
* Создать тестовое окружение, обеспечивающее требуемые условия. 
* Запустить тестовое окружение на выполнение. 
* Обеспечить сохранение результатов в файл для их последующей проверки. 
* После завершения выполнения сравнить полученные результаты со спецификацией. 

2. __Для работы с unit-тестами надо добавить в проект необходимые библиотеки__

- 2.1 Библиотеки для JUnit и TestNG поставляются с IntelliJ IDEA, но по умолчанию не включены в путь к классам вашего проекта или модуля. Следовательно, при создании тестового класса ссылки на класс TestCase или текстовые аннотации не разрешаются. Чтобы добавить необходимую библиотеку в путь к классам, вы можете использовать общую процедуру добавления зависимости к модулю. Соответствующие библиотеки расположены в следующих каталогах:
* JUnit библиотеки ( junit.jar и junit-4.12.jar): <IntelliJ IDEA directory>\lib;
* библиотека TestNG (testng-jdk15.jar): <IntelliJ IDEA directory>\plugins\testng\lib.
* ~~hastem - <IntelliJ IDEA directory>\plugins\testng\lib.~~

    IntelliJ IDEA может автоматически добавить необходимую библиотеку в путь к классам (Настройки проекта - Библиотеки) . 

- 2.2 Необходимо также  добавить в проект путь к классам тестов (они должны выделится зеленым).
```
src / main / java - для классов Java
src / test / java - для тестовых классов
```
- 2.3 Для создания теста в **редакторе кода** поместите курсор в строку, содержащую объявление класса. Нажмите Alt+Enter, чтобы просмотреть доступные намеренные действия. Выберите «Создать тест». (Обратите внимание **JUnit 4.12*** требуется)

3. Посмотрите [пример 1](https://github.com/olgmina/SWEngineering-technics.github.io/blob/28eac7ea8a68f47af6794c159906f66a7daa2bed/%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%201%20%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%9A%D0%B0%D0%BB%D1%8C%D0%BA%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0.pdf), и протестируйте аналогичным образом работу Процентного калькулятора Task0 или любой текущей Task

## Задание 5. Напишите unit-тест для тестирования различных сценариев работы Вашего приложения [программа Слайды, Индикатор, Фигуры]
    
    Например, для программы "Слайды" (паттерн Итератор) возможны следующие сценарии
    
1) "Показать следующий слайд" возможны два варианта исхода (класса эквивалентности), поэтому должен быть
          
Тест, когда следующий слайд существует
Тест, когда следующего слайда нет (конец коллекции)
    
2)  "Перейти на первый слайд" возможны два варианта исхода (класса эквивалентности):
    
Тест, когда первый слайд является текущим
Тест, когда первый слайд не является текущим
 
3)  "Перейти на последний слайд" возможны два варианта исхода (класса эквивалентности):

Тест, когда последний слайд является текущим
Тест, когда последний слайд не является текущим
    
4) "Показать предыдущий слайд"  возможны два варианта исхода (класса эквивалентности):
    
Тест, когда предыдущий слайд существует
Тест, когда предыдущего слайда нет (начало коллекции)
    
    Примеры [тестов см.](https://github.com/olgmina/SWEngineering-technics.github.io/blob/3726b0e2a1fe49f748605553da7b6fb42ffe5030/testing/unit-iterator.java)
    
**Отчет по должен содержать**
1. Код тестируемого класса из одного из Ваших проектов (programm)
2. Тест для проверки метода тестируемого класса
3. Тест для проверки интерфейса тестируемого класса
4. Тест проверки ошибочных условий либо покрытия двух путей.
- *ИЛИ на github  к  существующему Вашему проекту  добавить папку Test, в которой эти тесты разместить и прислать мне ссылку*

